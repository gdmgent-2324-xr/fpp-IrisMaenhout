/*
Auto-generated by: https://github.com/pmndrs/gltfjsx and adjusted by me
*/

import * as THREE from "three";
import React, { useEffect, useMemo, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";

import floorModel from "./color_switch_floor.glb";
import { CollisionEnterPayload, CuboidCollider, RigidBody } from "@react-three/rapier";

type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.Mesh;
    Cube001: THREE.Mesh;
    Cube002: THREE.Mesh;
    Cube003: THREE.Mesh;
    Cube004: THREE.Mesh;
    Cube005: THREE.Mesh;
    Cube006: THREE.Mesh;
    Cube007: THREE.Mesh;
    Cube008: THREE.Mesh;
    Cube009: THREE.Mesh;
    Cube010: THREE.Mesh;
    Cube011: THREE.Mesh;
    Cube012: THREE.Mesh;
    Cube013: THREE.Mesh;
    Cube014: THREE.Mesh;
    Cube025: THREE.Mesh;
    Cube026: THREE.Mesh;
    Cube027: THREE.Mesh;
    Cube028: THREE.Mesh;
    Cube029: THREE.Mesh;
    Cube030: THREE.Mesh;
    Cube031: THREE.Mesh;
    Cube032: THREE.Mesh;
    Cube033: THREE.Mesh;
    Cube034: THREE.Mesh;
  };
  materials: {
    Green: THREE.MeshStandardMaterial;
    White: THREE.MeshStandardMaterial;
    Pink: THREE.MeshStandardMaterial;
    Red: THREE.MeshStandardMaterial;
    Blue: THREE.MeshStandardMaterial;
    Orange: THREE.MeshStandardMaterial;
    Yellow: THREE.MeshStandardMaterial;
    Purple: THREE.MeshStandardMaterial;
  };
};

type props = {
  gameStarted: boolean;
};

export const MiniGameFloor: React.FC<props> = ({ gameStarted }) => {
  const { nodes, materials } = useGLTF(floorModel) as GLTFResult;

  const colors = useMemo(() => {
    return ["green", "white", "pink", "red", "blue", "orange", "yellow", "purple"]
  }, []);

  const [gameSettings, setGameSettings] = useState({
    randomColorTiles: "",
    randomColorText: "",
    score: 1,
    gameOver: false
  }); 

  const [highscore, setHighscore] =  useState<number>(() => {
    const storedHighscore = localStorage.getItem("highscore");
    return storedHighscore ? Number(storedHighscore) : 0;
  });



  const tileGroups: { [color: string]: THREE.Mesh[] } = {
    green: [nodes.Cube, nodes.Cube007, nodes.Cube011, nodes.Cube026],
    white: [nodes.Cube001, nodes.Cube010, nodes.Cube028],
    pink: [nodes.Cube002, nodes.Cube005, nodes.Cube034],
    red: [nodes.Cube003, nodes.Cube012, nodes.Cube029],
    blue: [nodes.Cube004, nodes.Cube013, nodes.Cube033],
    orange: [nodes.Cube006, nodes.Cube025, nodes.Cube032],
    yellow: [nodes.Cube008, nodes.Cube014, nodes.Cube031],
    purple: [nodes.Cube009, nodes.Cube027, nodes.Cube030],
    // Define other color groups similarly
  };


  const getMaterialFromColor = (color: string): THREE.MeshStandardMaterial => {
    switch (color) {
      case "green":
        return materials.Green;
      case "white":
        return materials.White;
      case "pink":
        return materials.Pink;
      case "red":
        return materials.Red;
      case "blue":
        return materials.Blue;
      case "orange":
        return materials.Orange;
      case "yellow":
        return materials.Yellow;
      case "purple":
        return materials.Purple;
      default:
        return materials.Green; // Default to Green material or change to a fallback material
    }
  };


  useEffect(()=>{
 
    const timeout = setTimeout(()=>{
      if(gameSettings.gameOver === false && gameSettings.randomColorTiles !== ""){

        sessionStorage.setItem("gameOver", "false");

        // Update score
        setGameSettings(prev => (
          {
          ...prev,
          score: prev.score + 1,
          }
        ));

        sessionStorage.setItem("score", `${gameSettings.score}`);
        
        // Update highscore if the current score exceeds the current highscore
        if(gameSettings.score > highscore){
          setHighscore(gameSettings.score);
          localStorage.setItem("highscore", `${gameSettings.score}`);
        }

      }
    }, 2500);

    return () => clearTimeout(timeout);

  }, [gameSettings, highscore]);


  useEffect(() => {
    
    const changeColorInterval = setInterval(() => {

        // Every 10s after the tiles are on it's original place again a new round will start

        if(gameSettings.gameOver === false && gameStarted === true){

          // Get random color
          const selectedColorIndex = Math.floor(Math.random() * colors.length);
          const selectedColor = colors[selectedColorIndex];

          sessionStorage.setItem("randomColor", selectedColor);

          setGameSettings((prev) => ({
            ...prev,
            randomColorText: selectedColor,
          }));

          // After 5s the tiles with the selected colors (randomColorTiles) will stay in place, the others will fall.
          setTimeout(() => {
            setGameSettings((prev) => ({
              ...prev,
              randomColorTiles: selectedColor,
            }));
          }, 5000);

          // Reset position of all tiles after 10s
          setTimeout(() => {
            sessionStorage.setItem("randomColor", "");

            setGameSettings((prev) => ({
              ...prev,
              randomColorTiles: "",
              randomColorText: "",
            }));

          }, 10000);

          
        }

      }, 10000);

    return () => clearInterval(changeColorInterval);
    
  }, [gameSettings, colors, gameStarted]);


  // Function to check if player survived after a collision
  function checkIfPlayerSurvived(event: CollisionEnterPayload): void {
    if (gameSettings.randomColorTiles !== "") {
      const userData = event.target.rigidBody?.userData;
      // Check the collided object or body to identify the name
      if (!(userData && typeof userData === "object" && "name" in userData)) {
        
        // Game is over
        sessionStorage.setItem("randomColor", "");
        sessionStorage.setItem("gameOver", "true");
        
        setGameSettings(prev => (
          {
            ...prev,
            randomColorTiles: "",   
            randomColorText: "",
            gameOver: true
          }
        ));
        
      }
    }
  
  }

  return (
    <group dispose={null} scale={2.5}>
      {/* Floor tiles */}
      {Object.entries(tileGroups).map(([color, tiles], index) => (
        <RigidBody 
          userData={{ name: color }}
          key={index} 
          colliders="cuboid" 
          type="fixed" 
          canSleep={false} 
          position={gameSettings.randomColorTiles === color || gameSettings.randomColorTiles === "" ? [0, 0, 0] : [0, -8, 0]}
          onCollisionEnter={checkIfPlayerSurvived}
        >
          {tiles.map((tile, idx) => (
            <mesh
              key={idx}
              castShadow
              receiveShadow
              geometry={tile.geometry}
              material={getMaterialFromColor(color)}
            />
          ))}
        </RigidBody>
      ))}

      {/* Colider to check if user fell and died */}
      <CuboidCollider
        args={[20, 10 ,20]}
        position={[0, -5.5, 0]}
        onCollisionEnter={checkIfPlayerSurvived}
      />

    </group>
  );
}

useGLTF.preload(floorModel);