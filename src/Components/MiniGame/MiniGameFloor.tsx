/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";

import floorModel from "./color_switch_floor.glb";
import { CollisionEnterPayload, RigidBody } from "@react-three/rapier";

type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.Mesh;
    Cube001: THREE.Mesh;
    Cube002: THREE.Mesh;
    Cube003: THREE.Mesh;
    Cube004: THREE.Mesh;
    Cube005: THREE.Mesh;
    Cube006: THREE.Mesh;
    Cube007: THREE.Mesh;
    Cube008: THREE.Mesh;
    Cube009: THREE.Mesh;
    Cube010: THREE.Mesh;
    Cube011: THREE.Mesh;
    Cube012: THREE.Mesh;
    Cube013: THREE.Mesh;
    Cube014: THREE.Mesh;
    Cube025: THREE.Mesh;
    Cube026: THREE.Mesh;
    Cube027: THREE.Mesh;
    Cube028: THREE.Mesh;
    Cube029: THREE.Mesh;
    Cube030: THREE.Mesh;
    Cube031: THREE.Mesh;
    Cube032: THREE.Mesh;
    Cube033: THREE.Mesh;
    Cube034: THREE.Mesh;
  };
  materials: {
    Green: THREE.MeshStandardMaterial;
    White: THREE.MeshStandardMaterial;
    Pink: THREE.MeshStandardMaterial;
    Red: THREE.MeshStandardMaterial;
    Blue: THREE.MeshStandardMaterial;
    Orange: THREE.MeshStandardMaterial;
    Yellow: THREE.MeshStandardMaterial;
    Purple: THREE.MeshStandardMaterial;
  };
};

type TileGroup = {
  [color: string]: THREE.Mesh[];
};

export function MiniGameFloor(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(floorModel) as GLTFResult;

  const colors = ["green", "white", "pink", "red", "blue", "orange", "yellow", "purple"];


  // const [selectedColor, setSelectedColor] = useState<string>(""); // Initialize with an empty string or default color

  const [gameSettings, setGameSettings] = useState({
    randomColorTiles: "",
    randomColorText: "",
    // resetTilesPosition: false,
    timeOutFall: 2000,
    score: 0,
    gameOver: false,
  });


  console.log(gameSettings.randomColorText);

  const tileGroups: { [color: string]: THREE.Mesh[] } = {
    green: [nodes.Cube, nodes.Cube007, nodes.Cube011, nodes.Cube026],
    white: [nodes.Cube001, nodes.Cube010, nodes.Cube028],
    pink: [nodes.Cube002, nodes.Cube005, nodes.Cube034],
    red: [nodes.Cube003, nodes.Cube012, nodes.Cube029],
    blue: [nodes.Cube004, nodes.Cube013, nodes.Cube033],
    orange: [nodes.Cube006, nodes.Cube025, nodes.Cube032],
    yellow: [nodes.Cube008, nodes.Cube014, nodes.Cube031],
    purple: [nodes.Cube009, nodes.Cube027, nodes.Cube030],
    // Define other color groups similarly
  };

  console.log(Object.entries(tileGroups));

  const getMaterialFromColor = (color: string): THREE.MeshStandardMaterial => {
    switch (color) {
      case "green":
        return materials.Green;
      case "white":
        return materials.White;
      case "pink":
        return materials.Pink;
      case "red":
        return materials.Red;
      case "blue":
        return materials.Blue;
      case "orange":
        return materials.Orange;
      case "yellow":
        return materials.Yellow;
      case "purple":
        return materials.Purple;
      default:
        return materials.Green; // Default to Green material or change to a fallback material
    }
  };


  useEffect(() => {
    const changeColorInterval = setInterval(() => {
      const selectedColorIndex = Math.floor(Math.random() * colors.length);
      const selectedColor = colors[selectedColorIndex];

      console.log(selectedColor);

      setGameSettings((prev) => ({
        ...prev,
        randomColorText: selectedColor,
      }));

      setTimeout(() => {
        setGameSettings((prev) => ({
          ...prev,
          randomColorTiles: selectedColor,
        }));
      }, 10000);

      setTimeout(() => {
        setGameSettings((prev) => ({
          ...prev,
          randomColorTiles: "",
          randomColorText: "",
        }));
      }, 20000); // Reset after 20 seconds

    }, 30000); // Change color every 30 seconds

    return () => clearInterval(changeColorInterval);
  }, []);



  // Function to check if player survived after a collision
  function checkIfPlayerSurvived(event: CollisionEnterPayload): void {
    if(gameSettings.randomColorTiles !== ""){
      const userData = event.target.rigidBody?.userData;
      // Check the collided object or body to identify the name
      if (userData && typeof userData === 'object' && 'name' in userData) {
        const collidedObjectColor = userData.name;
        if (collidedObjectColor === gameSettings.randomColorTiles) {
          // Player survived this round
          console.log("Survived round");
        } else {
          // Player didn't survive
          console.log("game over");
        }
      }
    }
  
  }


  return (
    <group {...props} dispose={null} scale={2.5}>
      {Object.entries(tileGroups).map(([color, tiles], index) => (
        <RigidBody 
          userData={{ name: color }}
          key={index} 
          colliders="cuboid" 
          type="fixed" 
          canSleep={false} 
          position={gameSettings.randomColorTiles === color || gameSettings.randomColorTiles === "" ? [0, 0, 0] : [0, -8, 0]}
          onCollisionEnter={checkIfPlayerSurvived}
        >
          {tiles.map((tile, idx) => (
            <mesh
              key={idx}
              castShadow
              receiveShadow
              geometry={tile.geometry}
              material={getMaterialFromColor(color)}
            />
          ))}
        </RigidBody>
      ))}

    </group>
  );
}

useGLTF.preload(floorModel);